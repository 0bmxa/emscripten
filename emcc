#!/usr/bin/env python

'''
emcc - compiler helper script
=============================

emcc is a drop-in replacement for a compiler like gcc or clang.

Tell your build system to use this instead of the compiler, linker, ar and
ranlib. All the normal build commands will be sent to this script, which
will proxy them to the appropriate build commands. For example, compilation
will be translated into calls to clang with -emit-llvm, and linking will
be translated into calls to llvm-link, and so forth.

Example uses:

 * For configure, instead of ./configure, cmake, etc., run emconfiguren.py
   with that command as an argument, for example

    emconfiguren.py ./configure [options]
  
   emconfiguren.py is a tiny script that just sets some environment vars
   as a convenience. The command just shown is equivalent to

    EMMAKEN_JUST_CONFIGURE=1 RANLIB=PATH/emcc AR=PATH/emcc CXX=PATH/em++ CC=PATH/emcc ./configure [options]

   where PATH is the path to this file.

   EMMAKEN_JUST_CONFIGURE tells emcc that it is being run in ./configure,
   so it should relay everything to gcc/g++. You should not define that when
   running make, of course.

 * With CMake, the same command will work (with cmake instead of ./configure). You may also be
   able to do the following in your CMakeLists.txt:

    SET(CMAKE_C_COMPILER "PATH/emcc")
    SET(CMAKE_CXX_COMPILER "PATH/em++")
    SET(CMAKE_LINKER "PATH/emcc")
    SET(CMAKE_CXX_LINKER "PATH/emcc")
    SET(CMAKE_C_LINK_EXECUTABLE "PATH/emcc")
    SET(CMAKE_CXX_LINK_EXECUTABLE "PATH/emcc")
    SET(CMAKE_AR "PATH/emcc")
    SET(CMAKE_RANLIB "PATH/emcc")

 * For SCons the shared.py can be imported like so:
    __file__ = str(Dir('#/project_path_to_emscripten/dummy/dummy'))
    __rootpath__ = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
    def path_from_root(*pathelems):
      return os.path.join(__rootpath__, *pathelems)
    exec(open(path_from_root('tools', 'shared.py'), 'r').read())
    
   For using the Emscripten compilers/linkers/etc. you can do:
    env = Environment()
    ...
    env.Append(CCFLAGS = COMPILER_OPTS)
    env.Replace(LINK = LLVM_LD)
    env.Replace(LD   = LLVM_LD)
   TODO: Document all relevant setup changes

After setting that up, run your build system normally.

Note the appearance of em++ instead of emcc
for the C++ compiler. This is needed for cases where we get
a C++ file with a C extension, in which case CMake can be told
to run g++ on it despite the .c extension, see

  https://github.com/kripken/emscripten/issues/6

(If a similar situation occurs with ./configure, you can do the same there too.)

emcc can be influenced by a few environment variables:

  EMMAKEN_NO_SDK - Will tell emcc *not* to use the emscripten headers. Instead
                   your system headers will be used.

  EMMAKEN_COMPILER - The compiler to be used, if you don't want the default clang.
'''

import os, sys, shutil
from subprocess import Popen, PIPE, STDOUT
from tools import shared

DEBUG = os.environ.get('EMCC_DEBUG')
SAVE_FILES = os.environ.get('EMCC_SAVE_FILES') # saves some of the intermediate files

################### XXX
print >> sys.stderr, '\n***This is a WORK IN PROGRESS***'
print >> sys.stderr, '***[%s]***\n' % str(sys.argv)
################### XXX

if DEBUG: print >> sys.stderr, 'emcc: ', ' '.join(sys.argv)

# Handle some global flags

if len(sys.argv) == 1:
  print 'emcc: no input files'
  exit(0)

if sys.argv[1] == '--version':
  print '''emcc (Emscripten GCC-like replacement) 2.0
Copyright (C) 2011 the Emscripten authors.
This is free and open source software under the MIT license.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  '''
  exit(0)
elif sys.argv[1] == '--help':
  this = os.path.basename('em++' if os.environ.get('EMMAKEN_CXX') else 'emcc')

  print '''%s [options] file...

Most normal gcc/g++ options will work, for example:
  --help                   Display this information
  --version                Display compiler version information

Options that are modified or new in %s include:
  -O0                      No optimizations (default)
  -O1                      Simple optimizations, including safe LLVM
                           optimizations, and no runtime assertions
  -O2                      As -O1, plus code flow optimization (relooper)
                           Warning: Compiling with this takes a long time!
  -O3                      As -O2, plus dangerous optimizations that may
                           break the generated code! If that happens, try
                           -O2 and then adding dangerous optimizations one
                           by one.
  -s OPTION=VALUE          JavaScript code generation option passed
                           into the emscripten compiler
  --typed-arrays <mode>    0: No typed arrays
                           1: Parallel typed arrays
                           2: Shared (C-like) typed arrays (default)
  --llvm-opts <level>      0: No LLVM optimizations (default)
                           1: Safe/portable LLVM optimizations
                           2: Full, unsafe/unportable LLVM optimizations;
                              this will almost certainly break the
                              generated code!

The target file, if specified (-o <target>), defines what will
be generated:

  <name>.js                JavaScript
  <name>.html              HTML with embedded JavaScript
  <name>.bc                LLVM bitcode (default)
  <name>.o                 LLVM bitcode

If -o <target> is *not* specified, the default is to generate
bitcode. In other words, to generate JavaScript or HTML, you must
specify so explicitly. The reason for this is that otherwise
many build systems would create a lot of JavaScript in
intermediary stages in a wasteful and inefficient manner.

The -c option (which tells gcc not to run the linker) will
also cause LLVM bitcode to be generated, as %s only generates
JavaScript in the final linking stage of building.

''' % (this, this, this)
  exit(0)

# If this is a configure-type thing, just do that
CONFIGURE_CONFIG = os.environ.get('EMMAKEN_JUST_CONFIGURE')
CMAKE_CONFIG = 'CMakeFiles/cmTryCompileExec.dir' in ' '.join(sys.argv)# or 'CMakeCCompilerId' in ' '.join(sys.argv)
if CONFIGURE_CONFIG or CMAKE_CONFIG:
  compiler = 'g++' if 'CXXCompiler' in ' '.join(sys.argv) or os.environ.get('EMMAKEN_CXX') else 'gcc'
  cmd = [compiler] + EMSDK_OPTS + sys.argv[1:]
  if DEBUG: print >> sys.stderr, 'emcc, just configuring: ', cmd
  exit(os.execvp(compiler, cmd))

if os.environ.get('EMMAKEN_COMPILER'):
  CXX = os.environ['EMMAKEN_COMPILER']
else:
  CXX = shared.CLANG

CC = shared.to_cc(CXX)

# If we got here from a redirection through emmakenxx.py, then force a C++ compiler here
if os.environ.get('EMMAKEN_CXX'):
  CC = CXX

CC_ADDITIONAL_ARGS = shared.COMPILER_OPTS # + ['-g']?
ALLOWED_LINK_ARGS = ['-f', '-help', '-o', '-print-after', '-print-after-all', '-print-before',
                     '-print-before-all', '-time-passes', '-v', '-verify-dom-info', '-version' ]
TWO_PART_DISALLOWED_LINK_ARGS = ['-L'] # Ignore thingsl like |-L .|

EMMAKEN_CFLAGS = os.environ.get('EMMAKEN_CFLAGS')
if EMMAKEN_CFLAGS: CC_ADDITIONAL_ARGS += EMMAKEN_CFLAGS.split(' ')

# ---------------- Utilities ---------------

def unsuffixed(name):
  return '.'.join(name.split('.')[:-1])

def unsuffixed_basename(name):
  return os.path.basename(unsuffixed(name))

# ---------------- End configs -------------

if len(sys.argv) == 1 or sys.argv[1] in ['x', 't']:
  # noop ar
  if DEBUG: print >> sys.stderr, 'emcc, just ar'
  sys.exit(0)

use_cxx = True
use_linker = True
header = False # pre-compiled headers. We fake that by just copying the file

opts = []
files = []
for i in range(1, len(sys.argv)):
  arg = sys.argv[i]
  if arg.startswith('-'):
    opts.append(arg)
  else:
    files.append(arg)
    if arg.endswith('.c'):
      use_cxx = False
    if arg.endswith(('.c', '.cc', '.cpp', '.dT')):
      use_linker = False
    if arg.endswith('.h') and sys.argv[i-1] != '-include':
      header = True
      use_linker = False

if '--version' in opts:
  use_linker = False

use_compiler = not use_linker and not header

if set(sys.argv[1]).issubset(set('-cruqs')): # ar
  sys.argv = sys.argv[:1] + sys.argv[3:] + ['-o='+sys.argv[2]]
  assert use_linker, 'Linker should be used in this case'

# Check if a target is specified
target = None
for i in range(len(sys.argv)-1):
  if sys.argv[i].startswith('-o='):
    raise Exception('Invalid syntax: do not use -o=X, use -o X')

  if sys.argv[i] == '-o':
    target = sys.argv[i+1]
    sys.argv = sys.argv[:i] + sys.argv[i+2:]
    break

if use_linker:
  # We could use the compiler code for this, but here we want to be careful to use all the linker flags we have been passed, sending them to ld
  call = shared.LLVM_LD
  newargs = ['-disable-opt']
  i = 0
  while i < len(sys.argv)-1:
    i += 1
    arg = sys.argv[i]
    if arg.startswith('-'):
      prefix = arg.split('=')[0]
      if prefix in ALLOWED_LINK_ARGS:
        newargs.append(arg)
      if arg in TWO_PART_DISALLOWED_LINK_ARGS:
        i += 1
    elif arg.endswith('.so'):
      continue # .so's do not exist yet, in many cases
    else:
      # not option, so just append
      newargs.append(arg)
  if target:
    actual_target = target
    if target.endswith('.js'):
      actual_target = unsuffixed(target) + '.bc'
    newargs.append('-o=' + actual_target)

  if DEBUG: print >> sys.stderr, "Running:", call, ' '.join(newargs)
  Popen([call] + newargs).communicate()

  # If we were not asked to generate JavaScript, stop
  if not target.endswith('.js'):
    exit(0)

  # Do not pass go, go directly to the compiler
  sys.argv = [sys.argv[0], actual_target]
  shutil.move(actual_target + '.bc', actual_target)
  use_compiler = True

if use_compiler:
  call = CXX if use_cxx else CC

  ## Parse args

  newargs = sys.argv[1:]

  opt_level = 0
  llvm_opt_level = 0

  for i in range(len(newargs)):
    if newargs[i].startswith('-O'):
      try:
        opt_level = int(newargs[i][2])
        assert 0 <= opt_level <= 3
      except:
        raise Exception('Invalid optimization level: ' + newargs[i])
      if opt_level >= 1:
        llvm_opt_level = 1
      newargs[i] = ''
    elif newargs[i].startswith('--llvm-opts'):
      assert '=' not in newargs[i], 'Invalid llvm opts parameter (do not use "=")'
      llvm_opt_level = eval(newargs[i+1])
      assert 0 <= llvm_opt_level <= 1, 'Only two levels of LLVM optimizations are supported so far, 0 (none) and 1 (safe)'
      newargs[i] = ''
      newargs[i+1] = ''
  newargs = [ arg for arg in newargs if arg is not '' ]

  settings_changes = []
  for i in range(len(newargs)):
    if newargs[i] == '-s':
      settings_changes.append(newargs[i+1])
      newargs[i] = newargs[i+1] = ''
    elif newargs[i].startswith('--typed-arrays'):
      assert '=' not in newargs[i], 'Invalid typed arrays parameter (do not use "=")'
      settings_changes.append('USE_TYPED_ARRAYS=' + newargs[i+1])
      newargs[i] = ''
      newargs[i+1] = ''
  newargs = [ arg for arg in newargs if arg is not '' ]

  input_files = []
  for i in range(len(newargs)): # find input files XXX this a simple heuristic. we should really analyze based on a full understanding of gcc params,
                                # right now we just assume that what is left contains no more |-x OPT| things
    arg = newargs[i]
    if arg.endswith(('.c', '.cpp', '.cxx', '.bc', '.o')): # we already removed -o <target>, so all these should be inputs
      input_files.append(arg)
      newargs[i] = ''
  newargs = [ arg for arg in newargs if arg is not '' ]

  assert len(input_files) > 0, 'emcc: no input files specified'

  newargs += CC_ADDITIONAL_ARGS

  specified_target = target
  target = specified_target if specified_target is not None else 'a.out.bc' # specified_target is the user-specified one, target is what we will generate

  target_basename = unsuffixed_basename(target)

  if '-c' in newargs: # -c means do not link in gcc, and for us, the parallel is to not go all the way to JS, but stop at bitcode
    target = target_basename + '.bc'

  final_suffix = target.split('.')[-1]

  # Apply optimization level settings
  if opt_level >= 1:
    shared.Settings.ASSERTIONS = 0
  if opt_level >= 2:
    shared.Settings.RELOOP = 1
    print >> sys.stderr, 'Warning: The relooper optimization can be very slow.'
  if opt_level >= 3:
    shared.Settings.CORRECT_SIGNS = 0
    shared.Settings.CORRECT_OVERFLOWS = 0
    shared.Settings.CORRECT_ROUNDINGS = 0
    shared.Settings.I64_MODE = 0
    shared.Settings.DOUBLE_MODE = 0
    shared.Settings.DISABLE_EXCEPTION_CATCHING = 1
    print >> sys.stderr, 'Warning: Applying some potentially unsafe optimizations! (Use -O2 if this fails.)'

  ## Compile source code to bitcode

  # First, generate LLVM bitcode. For each input file, we get base.o with bitcode
  newargs = newargs + ['-emit-llvm', '-c']

  for input_file in input_files:
    if input_file.endswith(('.c', '.cpp', '.cxx')):
      if DEBUG: print >> sys.stderr, "Running:", call, ' '.join(newargs)
      Popen([call] + newargs + [input_file]).communicate()
    else:
      shutil.copyfile(input_file, unsuffixed_basename(input_file) + '.o')

  # Optimize, if asked to
  if llvm_opt_level > 0:
    for input_file in input_files:
      shared.Building.llvm_opt(unsuffixed_basename(input_file) + '.o', 2, safe=llvm_opt_level < 2)

  # If we were just asked to generate bitcode, stop there
  if final_suffix in ['o', 'bc']:
    if final_suffix == 'bc':
      for input_file in input_files:
        shutil.move(unsuffixed_basename(input_file) + '.o', unsuffixed_basename(input_file) + '.bc')

    if specified_target:
      assert len(input_files) == 1, 'If a target is specified, and we are compiling to bitcode, there should be exactly one input file (c.f. gcc for why)'
      shutil.move(unsuffixed_basename(input_files[0]) + '.' + final_suffix, unsuffixed_basename(specified_target) + '.' + final_suffix)

    exit(0)

  ## Continue on to create JavaScript

  # First, combine the bitcode files if there are several
  if len(input_files) > 1:
    shared.Building.link(map(lambda input_file: unsuffixed_basename(input_file) + '.o', input_files), target_basename + '.bc')
  else:
    shutil.move(unsuffixed_basename(input_files[0]) + '.o', target_basename + '.bc')

  # Apply -s settings in newargs here (after -Ox, so they can override it)

  for change in settings_changes:
    key, value = change.split('=')
    exec('shared.Settings.' + key + ' = ' + value)

  temp_files = shared.TempFiles()
  temp_files.note(target_basename + '.bc')
  try:
    shared.Building.emscripten(target_basename + '.bc', append_ext=False)
    shutil.move(target_basename + '.bc.o.js', target_basename + '.js')
    if SAVE_FILES: shutil.copyfile(target_basename + '.js', 'save_' + target_basename + '.js')

    if opt_level >= 1:
      # js optimizer
      shared.Building.js_optimizer(target_basename + '.js', 'loopOptimizer')
      shutil.move(target_basename + '.js.jo.js', target_basename + '.js')
      if SAVE_FILES: shutil.copyfile(target_basename + '.js', 'save_' + target_basename + '.jo.js')

      # eliminator
      shared.Building.eliminator(target_basename + '.js')
      shutil.move(target_basename + '.js.el.js', target_basename + '.js')
      if SAVE_FILES: shutil.copyfile(target_basename + '.js', 'save_' + target_basename + '.jo.el.js')

    if opt_level >= 3:
      # closure
      shared.Building.closure_compiler(target_basename + '.js')
      shutil.move(target_basename + '.js.cc.js', target_basename + '.js')
      if SAVE_FILES: shutil.copyfile(target_basename + '.js', 'save_' + target_basename + '.jo.el.cc.js')

    if opt_level >= 1:
      # js optimizer
      shared.Building.js_optimizer(target_basename + '.js', 'simplifyExpressions')
      shutil.move(target_basename + '.js.jo.js', target_basename + '.js')
      if SAVE_FILES: shutil.copyfile(target_basename + '.js', 'save_' + target_basename + '.jo.el.cc.jo.js')

    # If we were asked to also generate HTML, do that
    if final_suffix == 'html':
      shell = open(shared.path_from_root('src', 'shell.html')).read()
      html = open(target_basename + '.html', 'w')
      html.write(shell.replace('{{{ SCRIPT_CODE }}}', open(target_basename + '.js').read()))
      html.close()
      temp_files.note(target_basename + '.js')

  finally:
    temp_files.clean()

  exit(0)

else: # header or such
  if DEBUG: print >> sys.stderr, 'Just copy.'
  shutil.copy(sys.argv[-1], sys.argv[-2])
  exit(0)



