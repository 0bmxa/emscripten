.. _Building-Projects:

======================================
Building Projects (under-construction)
======================================

Building large projects with Emscripten is very easy. Emscripten provides two simple scripts that configure your makefiles to use :ref:`emcc <emccdoc>` as a drop-in replacement for *gcc* — in most cases the rest of your project’s current build system remains unchanged.


Integrating with a build system
==================================

To build using Emscripten you need to replace *gcc* with *emcc* in your makefiles. This is done by calling *emconfigure* with the normal *configure* as an argument, and *emmake* with the *make* as an argument. 

Consider the case where you normally build with the following commands:

::

		./configure
		make

To build with Emscripten, you would instead use the following commands:

::
		
		# Run emconfigure with the normal configure command as an argument.
		./emconfigure ./configure
		
		# Run emmake with the normal make to generate linked LLVM bitcode.
		./emmake make
		
		# Compile the linked bitcode generated by make (project.bc) to JavaScript.
		#  'project.bc' should be replaced with your project's name and object code file type.
		#  [-Ox] represents the optimization and other compiler options used in the build.
		./emcc [-Ox] project.bc -o project.js


.. note:: The file output from *make* might have a different suffix: **.a** for a static library, **.so** for a shared library, **.o** or **.bc** for object files (these file extensions are the same as *gcc* would use for the different types). Irrespective of the file extension, these files contain linked LLVM bitcode that *emcc* can compile into JavaScript.

*emconfigure* runs *configure* but first sets the paths to use *emcc* instead of *gcc*. Similarly, *emmake* sets environment variables to point the compiler to Emscripten. Typically if you use *configure* or *cmake* or such, you don't need emmake — all the info is in the configure-generated files.

*Make* generates linked LLVM bitcode. It does not automatically generate JavaScript during linking because all the files must be compiled using the *same optimizations and compiler options* — and it makes sense to do this in the final conversion from bitcode to JavaScript. Optimizations are discussed in the following section.

The final step/line is to compile the linked bitcode into JavaScript. 


Optimizations
-------------

As mentioned above, the intermediate format is LLVM bitcode - object files contain that and not JavaScript. We do optimize like a normal compiler does, however: Each source file is optimized by LLVM as it is compiled into an object file. And, we perform additional optimizations when converting object files into JavaScript (optimizations that make sense only for JavaScript).

As a consequence, **you should provide the same optimization flags both when compiling source to object and object to JavaScript (or HTML)**.

For example

::

    # bad!
    ./emcc -O2 a.cpp -o a.bc
    ./emcc -O2 b.cpp -o b.bc
    ./emcc a.bc b.bc -o project.js

will not generate the best results, because no JavaScript-level optimizations were performed. Likewise,

::

    # also bad!
    ./emcc a.cpp -o a.bc
    ./emcc b.cpp -o b.bc
    ./emcc -O2 a.bc b.bc -o project.js

will also not be optimal, because no LLVM optimizations are done. The proper way would be to do

::

    # good!
    ./emcc -O2 a.cpp -o a.bc
    ./emcc -O2 b.cpp -o b.bc
    ./emcc -O2 a.bc b.bc -o project.js

By passing the same optimization flags during all stages, code will be properly optimized. Note that this goes not just for ``-O2`` and ``-O1`` but also for things like ``-s OPTION=VALUE`` which can affect optimization. Again, just pass the same flags during all compilation stages.

- You can control whether LLVM optimizations are run using ``--llvm-opts N`` where N is in 0-3. Sending ``-O2 --llvm-opts 0`` to *emcc* during all compilation stages will disable LLVM optimizations but utilize JavaScript optimizations. This can be useful when debugging a build failure.

Debug information
-----------------

If you want debug info, you need to compile the individual sources with ``-g``, exactly the same as with clang or *gcc* normally. This makes clang and llvm emit debug info in the bitcode files. You must then tell *emcc* during the bitcode to JavaScript stage to utilize that debug info, using ``-g`` or one of the specific ``-gN`` options (e.g. ``-g4`` for source maps support).

Notes
-----

- It is better to generate .so files and not .a. Archives (.a) have some odd behaviors when linked with other files, the linker tries to be 'clever' and discard stuff it thinks is not needed. Shared libraries (.so) are simpler, and we do elimination of unneeded code later anyhow, so they are recommended. This is generally a simple change in your project's build system.
- Make sure to use bitcode-aware llvm-ar instead of ar. ar may discard code.
- If you get multiply defined symbol errors, use ``llvm-nm`` to see which symbols are defined in each bitcode file being linked, in the link command where the error occurs. You may need to change how your project links libraries (e.g. from static to dynamic) or to avoid linking in a library more than once before the final link.

Manually using emcc
====================

The :ref:`Tutorial` showed how :ref:`emcc <emccdoc>` can be used to compile single files into JavaScript. *Emcc* can be used in all the other ways you would expect of *gcc*:

::

	# Generate a.out.js from C++. Can also take .ll (LLVM assembly) or .bc (LLVM bitcode) as input 
	./emcc src.cpp

	# Generate src.o containing LLVM bitcode.
	./emcc src.cpp -c

	# Generate result.js containing JavaScript.
	./emcc src.cpp -o result.js

	# Generate result.bc containing LLVM bitcode (the suffix matters).
	./emcc src.cpp -o result.bc

	# Generate a.out.js from two C++ sources.
	./emcc src1.cpp src2.cpp

	# Generate src1.o and src2.o, containing LLVM bitcode
	./emcc src1.cpp src2.cpp -c

	# Combine two LLVM bitcode files into a.out.js
	./emcc src1.o src2.o

	# Combine two LLVM bitcode files into another LLVM bitcode file
	./emcc src1.o src2.o -o combined.o

In addition to the capabilities it shares with *gcc*, *emcc* supports options to optimize code, control what debug information is emitted, generate HTML and other output formats, etc. These options are documented in the :ref:`emcc tool reference <emccdoc>` (``./emcc --help`` on the command line).

.. note:: The commmand ``./emconfigure ./configure`` is equivalent to the Linux command:

	::
	
		EMMAKEN_JUST_CONFIGURE=1 RANLIB=PATH/emranlib AR=PATH/emar CXX=PATH/em++ CC=PATH/emcc ./configure [options]

	``PATH`` is the path to *emcc* and ``EMMAKEN_JUST_CONFIGURE`` tells *emcc* that it is being run in ``./configure`` (and to relay everything to gcc/g++).
	
	You can also set the variables manually but the scripts make it easier.
	

System libraries
================

An ``sdl-config`` replacement is present in system/bin. Pointing configure scripts to system or system/bin should get them to use SDL properly.

Using libraries
================

If your project needs a standard system library, like for example zlib or glib, then if there is not built-in support in Emscripten for it, you will need to link it in manually. Built-in support exists for libc, libc++ and SDL, and for those you do not even need to add ``-lSDL`` or such - they will just work. But for other libraries, you need to build and link them.

- To build them, you would build them normally using *emcc*. Build them into bitcode, not JavaScript - which is easier, basically just run make using *emcc* as described above, and do not do anything additional to generate JavaScript from the bitcode.
- In your main project, as mentioned earlier in this document you need to add a command to go from bitcode to JavaScript. You should tell that command to also link in the library you built into bitcode. For example, if you built ``libstuff.bc``, and your final build command was ``emcc project.bc -o final.html``, then you should write ``emcc project.bc libstuff.bc -o final.html``. (Alternatively, you could use llvm-link to link the library with your other bitcode, etc.)

Issues
======

Build system self-execution
----------------------------

Some large projects, as part of their build procedure, generate executables and run them in order to generate input for later parts of the build system (for example, a parser may be built and then run on a grammar, which generates C/C++ code that implements that grammar). This is a problem when cross-compiling, including with Emscripten, since you cannot directly run the code you are generating.

The simplest solution is usually to build the project twice: Once natively, and once to JavaScript. When the JavaScript build procedure then fails on not being able to run a generated executable, you then copy that executable from the native build, and continue to build normally. This works for Python, for example (for more details, see ``tests/python/readme.txt``).

Another possible solution that makes sense in some cases is to modify the build scripts so that they build the generated executable natively. For example, this can be done by specifying two compilers in the build scripts, *emcc* and *gcc*, and using *gcc* just for generated executables. However, this can be more complicated than the previous solution because you need to modify the project build scripts, and also you need to work around cases where code is compiled and used both for the final result and for a generated executable (so you need to make sure it is built both natively and for JavaScript).

Dynamic linking
---------------

Emscripten's goal is to generate the fastest and smallest possible code, and for that reason it focuses on generating a single JavaScript file for an entire project. It is possible to link files at runtime (see :ref:`Linking`), but it isn't recommended.

Linking in libraries
--------------------

Since Emscripten does not have true dynamic linking - we won't link in code from some system location as we load an app - we approximate it to the best of our abilities. When you specify a dynamic library in a call to *emcc*, then it will be linked in as a static library, when you are building the final "executable", that is, JavaScript or HTML file. However, if you are linking together to bitcode, then dynamic libraries are **ignored**. The reason is you could link them twice to two libraries, then link those together. This works natively since actual linking will occur during startup, but for us, we use static linking, so had we linked them in, we would get an error on duplicate symbols.

The solution is to specify dynamic libraries once, in the command that builds to JavaScript or HTML. It's ok if you specify them elsewhere as well, but they will be ignored; the important thing is to not forget them during the final build stage.

Configure
----------

If your project uses *configure*, *cmake* or some other portable configuration method, it may do a lot of checks during the configure phase. *emcc* tries to get those to pass as much as it can, but in general it may not succeed. If you encounter such a case, you may need to disable checks in configure. Often the checks are just to verify that things will work, but things will actually work even though the checks fail.

If configure does checks that help determine important paths etc. for later in the build system, you may need to manually add those paths later and so forth.

Note that in general something like ``configure`` is not a good match for a cross-compiler like Emscripten. ``configure`` works very hard to get code to build natively for whatever local setup you have. With a cross-compiler, you are *ignoring* the native build system and the local system headers, and instead targeting a single standard target, so just writing out the values relevant for that target makes sense.

Alternatives to emcc
====================

You can in theory call clang, llvm-ld, etc. yourself. However, not using *emcc* is dangerous. One reason is that *emcc* will use the Emscripten bundled headers, while using Clang by itself will not, by default. This can lead to various errors. Also, using things like llvm-ld will result in unsafe/unportable LLVM optimizations being done by default. When you use *emcc*, it automatically handles all of that for you so that things work properly.

Examples
========

You can see how the large tests in ``tests/runner.py`` are built - the C/C++ projects there are built using their normal build systems, using *emcc* as detailed on this page. Specifically, the large tests include: ``freetype``, ``openjpeg``, ``zlib``, ``bullet`` and ``poppler``.

Also worth looking at the build scripts in the following projects, although several are not yet updated to use the new *emcc* tool:

-  https://github.com/kripken/ammo.js/blob/master/make.py
-  https://github.com/mbebenita/Broadway/blob/master/Avc/make.py
-  https://github.com/kripken/j2k.js/blob/master/make.py

